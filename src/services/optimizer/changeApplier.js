[]// /src/services/optimizer/changeApplier.js

const fs = require("fs");
const path = require("path");
const optimizerConfig = require("../../config/optimizerConfig");
const routingConfig = require("../../config/routingConfig");

const pendingChangesPath = path.join(__dirname, "../../data/pendingChanges.json");
const auditLogPath = path.join(__dirname, "../../data/optimizerAudit.log");

/**
 * Apply or queue a changeSet, depending on config and risk level.
 * @param {Object} changeSet
 * @returns {{applied: Array, pending: Array, dryRun: boolean, message: string}}
 */
function applyChanges(changeSet) {
  const { approvalMode, dryRun } = optimizerConfig;

  if (!changeSet || !changeSet.changes || changeSet.changes.length === 0) {
    return { applied: [], pending: [], dryRun, message: "No changes proposed." };
  }

  const applied = [];
  const pending = [];

  if (dryRun) {
    const enriched = assignIds(changeSet.changes);
    appendToPending(enriched);
    appendToAuditLog("DRY_RUN", enriched);
    return {
      applied,
      pending: enriched,
      dryRun,
      message: "Dry run: all changes stored as pending.",
    };
  }

  const autoApplyLowRisk =
    approvalMode === "AUTO_APPLY" && changeSet.riskLevel === "LOW";

  const enriched = assignIds(changeSet.changes);

  if (autoApplyLowRisk) {
    for (const change of enriched) {
      applyChangeToRoutingConfig(change);
      applied.push(change);
    }
    persistRoutingConfig(routingConfig);
  } else {
    appendToPending(enriched);
    pending.push(...enriched);
  }

  appendToAuditLog(
    autoApplyLowRisk ? "APPLIED_OR_QUEUED" : "QUEUED_ONLY",
    enriched
  );

  return {
    applied,
    pending,
    dryRun: false,
    message: autoApplyLowRisk
      ? "Applied low-risk changes, queued others if present."
      : "Queued all changes for review.",
  };
}

function assignIds(changes) {
  return changes.map((c) => ({
    ...c,
    id: generateId(),
    status: "PENDING",
    createdAt: new Date().toISOString(),
  }));
}

function applyChangeToRoutingConfig(change) {
  if (change.type === "ROUTING_WEIGHT_UPDATE") {
    const model = routingConfig.models[change.modelId];
    if (model) {
      model.weight = change.to;
    }
  }
}

function persistRoutingConfig(config) {
  const configPath = path.join(__dirname, "../../config/routingConfig.js");

  const fileContent =
    "// Auto-generated by D30 optimizer. Edit with care.\n\n" +
    "const routingConfig = " +
    JSON.stringify(config, null, 2) +
    ";\n\nmodule.exports = routingConfig;\n";

  fs.writeFileSync(configPath, fileContent, "utf8");
}

function appendToPending(changes) {
  let existing = [];
  if (fs.existsSync(pendingChangesPath)) {
    try {
      existing = JSON.parse(fs.readFileSync(pendingChangesPath, "utf8"));
    } catch {
      existing = [];
    }
  }
  const updated = [...existing, ...changes];
  fs.writeFileSync(pendingChangesPath, JSON.stringify(updated, null, 2), "utf8");
}

function appendToAuditLog(kind, changes) {
  const entries = changes.map((c) => ({
    kind,
    change: c,
    timestamp: new Date().toISOString(),
  }));
  const text = entries.map((e) => JSON.stringify(e)).join("\n") + "\n";
  fs.appendFileSync(auditLogPath, text, "utf8");
}

function generateId() {
  return (
    "chg_" +
    Math.random().toString(36).substring(2, 10) +
    Date.now().toString(36)
  );
}

module.exports = {
  applyChanges,
};